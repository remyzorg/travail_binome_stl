
\pdfminorversion 7
\pdfobjcompresslevel 3

\documentclass[a4paper]{article}
\special{papersize=210mm,297mm}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{cite}
\usepackage[francais]{babel}
\usepackage[bookmarks=false,colorlinks,linkcolor=blue]{hyperref}
\usepackage[top=3cm,bottom=2cm,left=3cm,right=2cm]{geometry}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{eso-pic}
\usepackage{array}
\usepackage{color}
\usepackage{url}
\usepackage{listings}
\usepackage{eurosym}
\usepackage{url}
\usepackage{textcomp}
\usepackage{fancyhdr} 

\definecolor{lightgray}{gray}{0.9}

\title{Rapport de TP Lustre}
\author{Rémy \textsc{El-Sibaie Besognet} -- Roven \textsc{Gabriel}}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


\begin{document}

\maketitle

\section{Metronome}

\subsection{Code Lustre}
\subsection{Automate}

TODO : automate en latex

\begin{verbatim}
      ctx->_V4 = ((ctx->_V3? _false : ctx->_V4) || ctx->_V1);
      ctx->_V6 = (ctx->_V1? ctx->_V2 : (ctx->_V3? 0 : ctx->_V6));
      ctx->_V7 = (ctx->_V3? _true : ((ctx->_V5 == 0)? (!ctx->_V7) : ctx->_V7));
      ctx->_V3 = _false;
      ctx->_V5 = ((!ctx->_V4)? 1 : ((ctx->_V1 || (ctx->_V5 == 0))? ctx->_V6 : (
ctx->_V5 - 1)));
      ctx->_V8 = ((ctx->_V5 == 0) && ctx->_V7);
      metronome_O_tic(ctx->client_data, ctx->_V8);
      ctx->_V9 = ((ctx->_V5 == 0) && (!ctx->_V7));
      metronome_O_tac(ctx->client_data, ctx->_V9);
      ctx->current_state = 0; break;
\end{verbatim}


\begin{verbatim}
   case 0:
      ctx->_V5 = (ctx->_V4 == 0);
      if(ctx->_V1){
         ctx->_V6 = ctx->_V2;
         ctx->_V4 = ctx->_V6;
      } else {
         ctx->_V6 = 0;
         ctx->_V4 = 1;
      }
      ctx->_V3 = (ctx->_V4 == 0);
      if(ctx->_V3){
         ctx->_V7 = _true;
         metronome_O_tic(ctx->client_data, ctx->_V7);
      } else {
         ctx->_V7 = _false;
         metronome_O_tic(ctx->client_data, ctx->_V7);
      }
      ctx->_V8 = _false;
      metronome_O_tac(ctx->client_data, ctx->_V8);
      if(ctx->_V1){
         ctx->current_state = 1; break;
      } else {
         ctx->current_state = 2; break;
      }
   break;
   
   case 1:
      ctx->_V5 = (ctx->_V4 == 0);
      if(ctx->_V1){
         ctx->_V6 = ctx->_V2;
         ctx->_V4 = ctx->_V6;
      } else {
         if(ctx->_V5){
            ctx->_V4 = ctx->_V6;
         } else {
            ctx->_V4 = (ctx->_V4 - 1);
         }
      }
      ctx->_V3 = (ctx->_V4 == 0);
      if(ctx->_V3){
         if(ctx->_V5){
            ctx->_V7 = _false;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _true;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         } else {
            ctx->_V7 = _true;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _false;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         }
      } else {
         ctx->_V7 = _false;
         metronome_O_tic(ctx->client_data, ctx->_V7);
         ctx->_V8 = _false;
         metronome_O_tac(ctx->client_data, ctx->_V8);
      }
      if(ctx->_V5){
         ctx->current_state = 3; break;
      } else {
         ctx->current_state = 1; break;
      }
   break;
   
   case 2:
      ctx->_V5 = (ctx->_V4 == 0);
      if(ctx->_V1){
         ctx->_V6 = ctx->_V2;
         ctx->_V4 = ctx->_V6;
      } else {
         ctx->_V4 = 1;
      }
      ctx->_V3 = (ctx->_V4 == 0);
      if(ctx->_V3){
         if(ctx->_V5){
            ctx->_V7 = _false;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _true;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         } else {
            ctx->_V7 = _true;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _false;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         }
      } else {
         ctx->_V7 = _false;
         metronome_O_tic(ctx->client_data, ctx->_V7);
         ctx->_V8 = _false;
         metronome_O_tac(ctx->client_data, ctx->_V8);
      }
      if(ctx->_V1){
         if(ctx->_V5){
            ctx->current_state = 3; break;
         } else {
            ctx->current_state = 1; break;
         }
      } else {
         if(ctx->_V5){
            ctx->current_state = 4; break;
         } else {
            ctx->current_state = 2; break;
         }
      }
   break;
   
   case 3:
      ctx->_V5 = (ctx->_V4 == 0);
      if(ctx->_V1){
         ctx->_V6 = ctx->_V2;
         ctx->_V4 = ctx->_V6;
      } else {
         if(ctx->_V5){
            ctx->_V4 = ctx->_V6;
         } else {
            ctx->_V4 = (ctx->_V4 - 1);
         }
      }
      ctx->_V3 = (ctx->_V4 == 0);
      if(ctx->_V3){
         if(ctx->_V5){
            ctx->_V7 = _true;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _false;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         } else {
            ctx->_V7 = _false;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _true;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         }
      } else {
         ctx->_V7 = _false;
         metronome_O_tic(ctx->client_data, ctx->_V7);
         ctx->_V8 = _false;
         metronome_O_tac(ctx->client_data, ctx->_V8);
      }
      if(ctx->_V5){
         ctx->current_state = 1; break;
      } else {
         ctx->current_state = 3; break;
      }
   break;
   
   case 4:
      ctx->_V5 = (ctx->_V4 == 0);
      if(ctx->_V1){
         ctx->_V6 = ctx->_V2;
         ctx->_V4 = ctx->_V6;
      } else {
         ctx->_V4 = 1;
      }
      ctx->_V3 = (ctx->_V4 == 0);
      if(ctx->_V3){
         if(ctx->_V5){
            ctx->_V7 = _true;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _false;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         } else {
            ctx->_V7 = _false;
            metronome_O_tic(ctx->client_data, ctx->_V7);
            ctx->_V8 = _true;
            metronome_O_tac(ctx->client_data, ctx->_V8);
         }
      } else {
         ctx->_V7 = _false;
         metronome_O_tic(ctx->client_data, ctx->_V7);
         ctx->_V8 = _false;
         metronome_O_tac(ctx->client_data, ctx->_V8);
      }
      if(ctx->_V1){
         if(ctx->_V5){
            ctx->current_state = 1; break;
         } else {
            ctx->current_state = 3; break;
         }
      } else {
         if(ctx->_V5){
            ctx->current_state = 2; break;
         } else {
            ctx->current_state = 4; break;
         }
      }
   break;
\end{verbatim}

\subsection{Analyse de l'automate}

question 3 : Analysez la structure de l'automate généré par lus2oc et
poc lorsque lus2oc est exécuté avec l'option -2 et comparez la à
l'automate implicite. Selon quelle(s) variable(s) l'automate implicite
a-t-il été déplié ?




\subsection{Vérification avec observateur}

\section{Arbitre de McMillan}
question 1 et 2
\section{Indeterminisme et quasi-synchronisme}

\subsection{Indeterminisme}

Dans l'énoncé le code correspondant à la valeur \texttt{reset} est
manquant. Le code complet est le suivant :

\begin{verbatim}
node env(S,R : bool; o : bool) returns (set,reset : bool);
let
  set = S and not R or (S and R and o);
  reset = R and not S or (S and R and not o);
tel
\end{verbatim}

Les valeurs de \texttt{set} et \texttt{reset} correspondent
respectivement aux formules $S \wedge \neg R$ et $\neg S \wedge R$ qui
ne peuvent pas être vrais en même temps. Par contre elles peuvent être
fausses en même temps ($R = S$). Si $R = S = vrai$, alors $set = o = \neg
\neg o = \neg reset$. On respecte donc la première
propriété. Sinon \texttt{set} et \texttt{reset} sont faux
(ce qui nous donne la première configuration)

On ne peut par contre pas vérifier le fait qu'à chaque instant le n\oe
ud Lustre puisse générer les trois configurations grâce à un
observateur. Si on utilise un observateur pour cela, il se pourraît que
les données en entrée soient telles que l'une des trois configurations
ne se produise jamais. Et donc nous n'aurions jamais la réponse, un
peu à la manière d'un problème indécidable. Nous sommes face à un problème
d'atteignabilité, alors que nous n'abordions jusque là que la propriété de
sûreté. On ne peut pas vérifier qu'un état est atteignable
dans le cas présent et avec les outils à notre disposition, parce
qu'un observateur va vérifier une propriété globale sur les états. Il
en est de même pour le model checker \texttt{xlesar} qui s'arrête si
une propriété est fausse. Il faudrait en fait ajouter la possibilité
d'exprimer des points fixes dans les formules.

\subsection{Quasi-synchronisme}



\end{document}

# Local Variables:
# compile-command: "rubber -d rapport.tex"
# End:
