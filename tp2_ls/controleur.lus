
node metronome (reset : bool; delay : int) returns (tic, tac : bool);
  var hz,  n :  int; first,  state :  bool;  
let 
  
  hz = if reset then delay else (0 -> pre hz);
  first = (false -> pre first) or reset;
  n = if not first then 1 else 
        if reset or pre n = 0 then hz
        else pre n - 1;

  state = true -> if pre n = 0 then not pre state else pre state;

  tic = n = 0 and state;
  tac = n = 0 and not state;
  
  
  assert (delay >= 0);

tel 
  


node observerP1 (tic,  tac : bool) returns (res :  bool);
let
  res = not (tic and tac);
tel
  

node observerP2 (tic, tac :  bool) returns (res :  bool);
var last_state : bool;
let
  last_state = 
    if tic then true else if tac then false else false -> pre last_state;
  res =  
    not (tic and pre last_state) or 
    not (tac and not pre last_state);
tel


node observerP3 (tic,  reset :  bool; hz :  int) returns (res :  bool);
var counter :  int; waiting_second :  bool;
let
  waiting_second = false -> not reset and (tic and not pre waiting_second);
  counter = if waiting_second then 0 -> pre counter + 1 else 0;

  res = if pre waiting_second and tic then counter = 2 * (hz + 1) 
        else true;
tel


node organizer (reset :  bool; delay :  int) returns (tic, tac, res :  bool);
var hz : int;
let 
  
  hz = if reset then delay else (0 -> pre hz);
  tic, tac = metronome(reset,  delay);

  res = observerP3(tic, reset, hz) ;
    and observerP1(tic, tac) 
    and observerP2(tic, tac);
tel
  



node cell (tk_in, ovr_in, gr_in, rq_in :  bool) returns
  (ack_out, ovr_out, tk_out, gr_out : bool)
var w, accept, token : bool;  
let 
  
  w = false -> req_in and (pre tk_in or pre w)
  
  token = false -> pre tk_in and (  or and  )  

  ovr_out = false -> ovr_in and token

  accept = false -> gr_in or token; 

  ack_out = false -> req_in and accept

/* TODO */


tel